use std::fs;
use std::path::Path;

use anyhow::Context;
use serde::{Deserialize, Serialize};

use crate::get_installed_mods_sync;

#[derive(Debug, Serialize, Deserialize)]
pub struct ModBlacklist {
    name: String,
    file: String,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ModBlacklistProfile {
    name: String,
    mods: Vec<ModBlacklist>,
}

pub fn apply_mod_blacklist_profile(
    game_path: &String,
    profile_name: &String,
) -> anyhow::Result<()> {
    let profile = get_mod_blacklist_profiles(game_path)
        .into_iter()
        .find(|v| &v.name == profile_name)
        .context("Profile not found")?;

    let blacklist = Path::new(game_path).join("Mods").join("blacklist.txt");

    let mods = get_installed_mods_sync(game_path.clone() + "/Mods");

    fs::write(
        blacklist,
        (format!(
            "# Profile: {}\n# This file is generated by CeleMod\n\n\n",
            profile_name
        ) + &mods.iter()
            .filter_map(|v| {
                profile.mods.iter().find(|m| m.name == v.name).map(|mod_name| format!("# {}\n", mod_name.file))
            })
            .collect::<Vec<String>>()
            .join("\n")),
    )?;

    Ok(())
}

pub fn get_current_profile(game_path: &String) -> anyhow::Result<String> {
    let blacklist = Path::new(game_path).join("Mods").join("blacklist.txt");
    let profiles = get_mod_blacklist_profiles(game_path);

    if blacklist.exists() {
        let data = fs::read_to_string(blacklist).unwrap();
        let current_profile = profiles
            .iter()
            .find(|v| v.name == data.lines().next().unwrap().replace("# Profile: ", ""));

        if let Some(current_profile) = current_profile {
            Ok(current_profile.name.clone())
        } else {
            Ok("Default".to_string())
        }
    } else {
        Ok("Default".to_string())
    }
}

pub fn get_mod_blacklist_profiles(game_path: &String) -> Vec<ModBlacklistProfile> {
    let mut profiles = vec![];
    let blacklist_path = Path::new(game_path).join("celemod_blacklist_profiles");
    if blacklist_path.exists() {
        for entry in fs::read_dir(blacklist_path).unwrap() {
            let entry = entry.unwrap();
            let path = entry.path();
            if path.extension().unwrap() == "json" {
                let data = fs::read_to_string(path).unwrap();
                let profile: ModBlacklistProfile = serde_json::from_str(&data).unwrap();
                profiles.push(profile);
            }
        }
    } else {
        fs::create_dir_all(&blacklist_path).unwrap();
        // convert default blacklist to profile
        let default_blacklist = Path::new(&game_path).join("Mods").join("blacklist.txt");
        if default_blacklist.exists() {
            let data = fs::read_to_string(default_blacklist).unwrap();
            let mods = get_installed_mods_sync(game_path.clone() + "/Mods");
            let profile = ModBlacklistProfile {
                name: "Default".to_string(),
                mods: data
                    .lines()
                    .map(|v|v.trim())
                    .filter(|v| !v.starts_with('#'))
                    .map(|v| {
                        ModBlacklist {
                            name: {
                                if let Some(mod_name) = mods.iter().find(|m| m.file == v) {
                                    mod_name.name.clone()
                                } else {
                                    v.to_string()
                                }
                            },
                            file: v.to_string(),
                        }
                    })
                    .collect(),
            };

            fs::write(
                blacklist_path.join("Default.json"),
                serde_json::to_string_pretty(&profile).unwrap(),
            )
            .unwrap();

            profiles.push(profile);
        }
    }
    profiles
}

pub fn switch_mod_blacklist_profile(
    game_path: &String,
    profile_name: &String,
    mods: Vec<(&String, &String)>,
    enabled: bool,
) -> anyhow::Result<()> {
    let profile = get_mod_blacklist_profiles(game_path)
        .into_iter()
        .find(|v| &v.name == profile_name)
        .context("Profile not found")?;

    // remove mod_name from profile or add it
    let mut new_profile = profile;

    if !enabled {
        for (mod_name, mod_file) in mods {
            if new_profile.mods.iter().any(|v| &v.name == mod_name) {
                continue;
            }
            new_profile.mods.push(ModBlacklist {
                name: mod_name.clone(),
                file: mod_file.clone(),
            });
        }
    } else {
        new_profile.mods.retain(|v| {
            !mods.iter().any(|(mod_name, _)| &&v.name == mod_name)
        });
    }

    let blacklist_path = Path::new(game_path)
        .join("celemod_blacklist_profiles")
        .join(format!("{}.json", new_profile.name));

    fs::write(
        blacklist_path,
        serde_json::to_string_pretty(&new_profile).unwrap(),
    )?;

    Ok(())
}

pub fn new_mod_blacklist_profile(game_path: &String, profile_name: &String) -> anyhow::Result<()> {
    let blacklist_path = Path::new(game_path)
        .join("celemod_blacklist_profiles")
        .join(format!("{}.json", profile_name));

    fs::write(
        blacklist_path,
        serde_json::to_string_pretty(&ModBlacklistProfile {
            name: profile_name.clone(),
            mods: vec![],
        })
        .unwrap(),
    )?;

    Ok(())
}

pub fn remove_mod_blacklist_profile(
    game_path: &String,
    profile_name: &String,
) -> anyhow::Result<()> {
    let blacklist_path = Path::new(game_path)
        .join("celemod_blacklist_profiles")
        .join(format!("{}.json", profile_name));

    fs::remove_file(blacklist_path)?;

    Ok(())
}
